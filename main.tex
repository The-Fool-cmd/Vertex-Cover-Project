\documentclass{llncs}

\usepackage[utf8]{inputenc}
\usepackage[romanian]{babel}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{graphicx}

\begin{document}

\title{Proiect Analiza Algoritmilor: Problema Vertex Cover}
\author{Savu Vlad-Ștefan}
\institute{Facultatea de Automatică și Calculatoare, \\
Universitatea Politehnica din București \\
\email{vlad.savu@stud.acs.upb.ro}}

\maketitle

\begin{abstract}
Această lucrare analizează problema acoperirii cu vârfuri (Vertex Cover), o problemă fundamentală în teoria grafurilor și una dintre cele 21 de probleme NP-complete identificate de Richard Karp în 1972. Studiul de față urmărește compararea performanței dintre o soluție exactă, bazată pe tehnica backtracking, și două abordări euristice/aproximative. Analiza se concentrează pe compromisul dintre timpul de execuție și calitatea soluției obținute (apropierea de cardinalitatea minimă).
\keywords{Vertex Cover \and NP-Complete \and Independent Set \and Algoritmi Aproximativi \and Backtracking \and Optimizare combinatorie.}
\end{abstract}

\section{Introducere}

\subsection{Definirea Problemei}
Problema acoperirii cu vârfuri (\textit{Vertex Cover}) este o problemă clasică de optimizare a grafurilor. Fiind dat un graf neorientat $G=(V,E)$, o acoperire cu vârfuri este o submulțime de noduri $C \subseteq V$ astfel încât pentru fiecare muchie $\{u,v\} \in E$, cel puțin unul dintre capetele $u$ sau $v$ (sau ambele) aparține mulțimii $C$.



Scopul principal este identificarea unei acoperiri de cardinalitate minimă, numită \textit{Minimum Vertex Cover}. În varianta sa de decizie, problema întreabă dacă există o acoperire de dimensiune cel mult $k$. Această variantă este demonstrată a fi NP-completă, ceea ce implică faptul că, în absența unor dovezi contrare privind relația $P=NP$, nu există un algoritm de timp polinomial care să rezolve problema pe cazul general.

\subsection{Context Istoric și Importanță}
Vertex Cover ocupă un loc central în cercetarea complexității computaționale. Ea este strâns legată de alte probleme celebre, precum \textit{Independent Set} și \textit{Clique}. De fapt, o mulțime $S$ este un set independent în graful $G$ dacă și numai dacă complementul său, $V \setminus S$, este o acoperire cu vârfuri. Această dualitate este adesea utilizată în demonstrațiile de NP-duritate și în transformările polinomiale dintre probleme.

\subsection{Aplicații practice și conexiuni cu alte probleme}
Problema Vertex Cover nu este izolată; ea face parte dintr-o familie de probleme de optimizare combinatorie, servind drept model pentru numeroase situații reale:

\begin{itemize}
    \item \textbf{Legătura cu Problema Rucsacului (Knapsack):} Deși Knapsack pare o problemă de inventar, în variantele sale pe grafuri, aceasta se intersectează cu Vertex Cover. Dacă fiecare nod are un cost de instalare diferit, problema devine una de tip Knapsack: selectarea subsetului de noduri cu cost minim care să acopere toate muchiile sub o constrângere de resurse.
    
    \item \textbf{Bioinformatică și Eliminarea Conflictelor:} În alinierea secvențelor de ADN, se construiesc grafuri unde muchiile reprezintă date contradictorii. Rezolvarea Vertex Cover permite identificarea setului minim de date ce trebuie eliminate pentru a obține un set consistent.

    \item \textbf{Cyber-Security (Sisteme IDS):} În rețelele mari, monitorizarea fiecărui pachet este costisitoare. Vertex Cover este utilizată pentru a plasa sisteme de detecție a intruziunilor în noduri strategice, asigurând monitorizarea tuturor conexiunilor.

    \item \textbf{Designul Circuitelor VLSI:} În proiectarea cipurilor, Vertex Cover ajută la minimizarea numărului de puncte de testare necesare pentru a verifica integritatea circuitelor pe suprafața siliciului.
\end{itemize}

\section{Demonstrație NP-Hard}

\subsection{Apartenența la clasa NP}
Pentru a demonstra că problema Vertex Cover aparține clasei NP, trebuie să arătăm că o \textbf{propunere de soluție} (un set de noduri) poate fi verificată în timp polinomial.

Presupunem că primim o submulțime de noduri $C \subseteq V$ despre care se afirmă că este o acoperire validă. Algoritmul de verificare parcurge fiecare muchie $\{u, v\} \in E$ și verifică dacă cel puțin unul dintre capete se află în setul $C$. Deoarece numărul de muchii este finit, iar verificarea fiecăreia se face rapid prin interogarea listei $C$, complexitatea totală este $O(E)$. Prin urmare, deoarece verificarea se face în timp polinomial, Vertex Cover aparține clasei NP.

\subsection{Reducerea de la Independent Set}
Demonstrăm că Vertex Cover este NP-Hard folosind o reducere polinomială de la problema \textit{Independent Set}, despre care se știe deja că este NP-Hard.



\begin{theorem}
Fie $G=(V,E)$ un graf neorientat. O mulțime $S \subseteq V$ este un set independent dacă și numai dacă complementul său, $V \setminus S$, este o acoperire cu vârfuri (Vertex Cover) pentru graful $G$.
\end{theorem}

\begin{proof}
$(\Rightarrow)$ Presupunem că $S$ este un set independent. Conform definiției, nicio muchie din $E$ nu are ambele capete în $S$. Acest lucru înseamnă că pentru orice muchie $\{u, v\}$, cel puțin unul dintre noduri ($u$ sau $v$) trebuie să se afle în afara lui $S$, adică în $V \setminus S$. Astfel, $V \setminus S$ acoperă toate muchiile, deci este un Vertex Cover.

$(\Leftarrow)$ Presupunem că $V \setminus S$ este o acoperire cu vârfuri. Atunci, orice muchie din graf are cel puțin un capăt în $V \setminus S$. Rezultă că nicio muchie nu poate avea ambele capete în $S$. Aceasta este exact definiția unui set independent, deci $S$ este un set independent.
\end{proof}

Concluzionăm că, deoarece putem transforma orice instanță a problemei Independent Set într-o instanță de Vertex Cover printr-o simplă operație de complementare (care durează timp polinomial), problema Vertex Cover este NP-Hard.

\section{Algoritmi pentru problema Vertex Cover}

Având în vedere caracterul NP-complet al problemei Vertex Cover, abordările algoritmice se împart în două mari categorii: algoritmi exacți, care garantează obținerea soluției optime dar au complexitate exponențială, și algoritmi aproximativi sau euristici, care sacrifică exactitatea în favoarea unui timp de execuție redus. În această secțiune sunt analizate un algoritm exact bazat pe backtracking (Branch \& Bound) și două abordări aproximative clasice.

\subsection{Algoritm exact bazat pe Backtracking (Branch \& Bound)}

\subsubsection{Ideea de bază}
Algoritmul exact pornește de la observația fundamentală conform căreia, pentru orice muchie $\{u,v\} \in E$, cel puțin unul dintre noduri trebuie să aparțină acoperirii. Această constrângere permite construirea unui arbore de decizie binar, în care fiecare ramură corespunde includerii unuia dintre capetele muchiei selectate.

Tehnica Branch \& Bound extinde backtracking-ul clasic prin introducerea unor limite (bound-uri) care permit eliminarea timpurie a ramurilor ce nu pot conduce la o soluție mai bună decât cea deja cunoscută.

\subsubsection{Descrierea algoritmului}
Algoritmul funcționează recursiv după următorii pași:
\begin{enumerate}
    \item Se selectează o muchie neacoperită $\{u,v\}$.
    \item Se creează două ramuri:
    \begin{itemize}
        \item se include $u$ în soluție;
        \item se include $v$ în soluție.
    \end{itemize}
    \item Se elimină din graf muchiile acoperite de nodul ales.
    \item Se continuă recursiv până când nu mai există muchii neacoperite.
    \item Ramurile pentru care cardinalitatea soluției parțiale depășește cea mai bună soluție cunoscută sunt eliminate (pruning).
\end{enumerate}

\subsubsection{Pseudocod}
\begin{verbatim}
BranchAndBound(G, C):
    if E(G) = ∅:
        actualizează soluția optimă
        return

    if |C| ≥ best:
        return

    alege muchia (u, v)

    BranchAndBound(G - u, C ∪ {u})
    BranchAndBound(G - v, C ∪ {v})
\end{verbatim}

\subsubsection{Complexitate}
\begin{itemize}
    \item \textbf{Timp:} $O(2^{|V|})$ în cel mai defavorabil caz.
    \item \textbf{Spațiu:} $O(|V|)$ datorită adâncimii maxime a recursiei.
\end{itemize}

Acest algoritm este aplicabil exclusiv grafurilor de dimensiuni mici, fiind utilizat în special în contexte educaționale sau pentru validarea soluțiilor aproximative.

\subsubsection{Avantaje și dezavantaje}

\textbf{Avantaje:}
\begin{itemize}
    \item Produce întotdeauna o soluție optimă pentru problema Vertex Cover.
    \item Permite eliminarea eficientă a ramurilor nepromițătoare prin tehnica de pruning (Branch \& Bound).
    \item Este util pentru validarea soluțiilor aproximative sau pentru grafuri foarte mici.
\end{itemize}

\textbf{Dezavantaje:}
\begin{itemize}
    \item Are complexitate exponențială în cel mai defavorabil caz.
    \item Nu este scalabil pentru grafuri de dimensiuni medii sau mari.
    \item Consumul de timp crește rapid odată cu numărul de noduri.
\end{itemize}


---

\subsection{Algoritm aproximativ 2-approx bazat pe muchii}

\subsubsection{Principiul algoritmului}
Algoritmul aproximativ clasic pentru Vertex Cover se bazează pe selectarea repetată a unei muchii arbitrare și includerea ambelor capete ale acesteia în acoperire. Muchiile incidente acestor noduri sunt apoi eliminate din graf.

Această strategie este echivalentă cu construirea unei potriviri maxime (maximal matching), iar acoperirea rezultată este formată din toate nodurile potrivirii.

\subsubsection{Pseudocod}
\begin{verbatim}
ApproxVertexCover(G):
    C ← NULL
    while E(G) != NULL:
        alege muchia (u, v)
        C ← C ∪ {u, v}
        elimină toate muchiile incidente lui u sau v
    return C
\end{verbatim}

\subsubsection{Garanția de aproximare}
Fie $OPT$ cardinalitatea unei acoperiri minime și $ALG$ soluția produsă de algoritm. Atunci:
\[
ALG \leq 2 \cdot OPT
\]

Această limită este strict demonstrabilă, deoarece fiecare muchie selectată trebuie să fie acoperită de cel puțin un nod în soluția optimă, iar algoritmul include cel mult două.

\subsubsection{Complexitate}
\begin{itemize}
    \item \textbf{Timp:} $O(|E|)$
    \item \textbf{Spațiu:} $O(|V|)$
\end{itemize}
\subsubsection{Avantaje și dezavantaje}

\textbf{Avantaje:}
\begin{itemize}
    \item Rulează în timp polinomial, fiind eficient chiar și pentru grafuri mari.
    \item Are o garanție teoretică de aproximare de 2.
    \item Este simplu de implementat și de explicat.
\end{itemize}

\textbf{Dezavantaje:}
\begin{itemize}
    \item Nu garantează obținerea unei soluții optime.
    \item Calitatea soluției poate fi semnificativ mai slabă decât optimul în unele cazuri.
    \item Alegerea arbitrară a muchiilor poate influența rezultatul final.
\end{itemize}

---

\subsection { Algoritm exact parametrizat prin Kernelization }

\subsubsection{Ideea de bază}
Kernelization este o tehnică din cadrul algoritmilor parametrizați (FPT) care reduce dimensiunea problemei Vertex Cover folosind parametrul $k$, dimensiunea dorită a acoperirii. Prin aplicarea unor reguli de reducere, graful inițial este comprimat la un \emph{kernel} de dimensiune $O(k^2)$, fără a pierde informația necesară pentru a găsi o soluție optimă.

Ulterior, se poate aplica un algoritm exact (de exemplu Branch \& Bound) pe kernelul redus pentru a determina acoperirea minimă.

\subsubsection{Descrierea algoritmului}
Algoritmul funcționează recursiv după următorii pași:

\begin{enumerate}
    \item Aplică reguli de reducere pentru noduri și muchii redundante:
    \begin{itemize}
        \item Noduri de grad zero pot fi eliminate.
        \item Noduri de grad unul pot fi incluse automat în acoperire și eliminate împreună cu muchiile incidente.
    \end{itemize}
    \item Se repetă reducerea până când graful nu mai poate fi comprimat.
    \item Graful rezultat (kernel) are $O(k^2)$ noduri și muchii.
    \item Se aplică un algoritm exact pe kernel pentru a găsi Vertex Cover-ul minim.
\end{enumerate}

\subsubsection{Pseudocod}
\begin{verbatim}
KernelizationVC(G, k):
    while reducere_posibila(G):
        aplica reguli de reducere(G)
    if |V(G)| > k^2:
        return "Nu există VC de dimensiune k"
    else:
        return BranchAndBound(G, ∅)
\end{verbatim}

\subsubsection{Complexitate}
\begin{itemize}
    \item \textbf{Timp:} polinomial pentru reducerea kernelului; timpul algoritmului exact depinde de dimensiunea kernelului ($O(2^{O(k^2)})$).
    \item \textbf{Spațiu:} $O(k^2)$ pentru kernel.
\end{itemize}

\subsubsection{Avantaje / Dezavantaje}
\begin{itemize}
    \item \textbf{Avantaje:} 
    \begin{itemize}
        \item Permite tratarea grafurilor mari atunci când soluția optimă este mică.
        \item Combină eficiența reducerii cu exactitatea algoritmului Branch \& Bound.
    \end{itemize}
    \item \textbf{Dezavantaje:} 
    \begin{itemize}
        \item Necesită cunoștințe avansate de algoritmi parametrizați.
        \item Ineficient dacă parametrul $k$ nu este mic.
    \end{itemize}
\end{itemize}

\subsection{Relaxare liniară și rotunjire}

\subsubsection{Formulare prin programare liniară}
Problema Vertex Cover poate fi formulată ca un program liniar întreg, în care fiecărui nod $v \in V$ îi este asociată o variabilă binară $x_v$, ce indică dacă nodul este inclus sau nu în acoperire:
\[
x_v =
\begin{cases}
1, & \text{dacă } v \in C \\
0, & \text{altfel}
\end{cases}
\]

Funcția obiectiv urmărește minimizarea cardinalității acoperirii:
\[
\min \sum_{v \in V} x_v
\]

Constrângerile asigură faptul că fiecare muchie este acoperită:
\[
x_u + x_v \geq 1 \quad \forall \{u,v\} \in E
\]
\[
x_v \in \{0,1\}
\]

Această formulare este echivalentă cu problema originală, însă fiind un program liniar întreg, rămâne NP-dificilă.

Prin relaxarea condiției de integritate și permiterea valorilor fracționare:
\[
x_v \in [0,1]
\]
problema devine un program liniar clasic, care poate fi rezolvat în timp polinomial folosind metode precum algoritmul simplex sau metode de punct interior.

\subsubsection{Rotunjirea soluției}
Soluția fracționară obținută prin relaxare liniară nu reprezintă, în general, o acoperire validă, deoarece valorile variabilelor nu mai sunt binare. Pentru a obține o soluție fezabilă pentru problema Vertex Cover, se aplică o tehnică de rotunjire.

Regula standard de rotunjire este:
\[
x_v \geq 0.5 \Rightarrow v \in C
\]

Această regulă garantează că pentru orice muchie $\{u,v\}$, cel puțin unul dintre capete va fi inclus în acoperire, deoarece constrângerea $x_u + x_v \geq 1$ implică faptul că cel puțin una dintre variabile este mai mare sau egală cu $0.5$.

\subsubsection{Complexitate}
\begin{itemize}
    \item \textbf{Timp:} $O(\text{LP}(V,E))$, unde $\text{LP}(V,E)$ reprezintă timpul de rezolvare al programului liniar, polinomial în $|V|$ și $|E|$.
    \item \textbf{Spațiu:} $O(|V| + |E|)$.
\end{itemize}

\subsubsection{Avantaje și dezavantaje}

\textbf{Avantaje:}
\begin{itemize}
    \item Problema relaxată poate fi rezolvată în timp polinomial folosind algoritmi standard de programare liniară.
    \item Oferă o garanție teoretică de aproximare de 2 pentru problema Vertex Cover.
    \item Abordarea este bazată pe fundamente matematice solide și permite extinderi către alte probleme de optimizare combinatorială.
    \item Soluția fracționară poate oferi informații utile despre structura soluției optime.
\end{itemize}

\textbf{Dezavantaje:}
\begin{itemize}
    \item Necesită utilizarea unui solver de programare liniară, ceea ce poate crește complexitatea implementării.
    \item Soluția obținută după rotunjire nu este optimă în general.
    \item Pentru grafuri foarte mari, costul rezolvării programului liniar poate deveni semnificativ.
\end{itemize}



\begin{thebibliography}{8}

\bibitem{karp1972}
Karp, R.M.: Reducibility among combinatorial problems. In: Miller, R.E., Thatcher, J.W. (eds.) Complexity of Computer Computations, pp. 85--103. Plenum Press, New York (1972). 
\textit{(Sursa principală pentru clasificarea Vertex Cover ca fiind NP-completă.)}

\bibitem{clrs2009}
Cormen, T.H., Leiserson, C.E., Rivest, R.L., Stein, C.: Introduction to Algorithms, 3rd edn. MIT Press, Cambridge (2009). 
\textit{(Manualul standard de algoritmică folosit pentru definițiile formale și demonstrația reducerii de la Independent Set.)}

\bibitem{garey1979}
Garey, M.R., Johnson, D.S.: Computers and Intractability: A Guide to the Theory of NP-Completeness. W. H. Freeman and Company, San Francisco (1979). 
\textit{(Cartea de referință pentru demonstrarea NP-durității diverselor probleme.)}

\bibitem{sipser2012}
Sipser, M.: Introduction to the Theory of Computation, 3rd edn. Cengage Learning (2012). 
\textit{(Sursa pentru conceptele de clase de complexitate, certificate și verificatori.)}

\bibitem{vazirani_approx}
V. Vazirani,
\textit{Approximation Algorithms},
Springer, 2001.
\textit{(Sursa pentru demonstrația teoretică a algoritmului 2-approx și pentru relaxarea liniară și rotunjire.)}

\bibitem{niedermeier_kernel}
R. Niedermeier,
\textit{Invitation to Fixed-Parameter Algorithms},
Oxford University Press, 2006.
\textit{(Sursa pentru kernelization în Vertex Cover și reducerea la kernel de dimensiune $O(k^2)$.)}



\end{thebibliography}

\end{document}
